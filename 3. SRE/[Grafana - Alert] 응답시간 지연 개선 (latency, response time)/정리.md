#### 쿼리 선정

1. 평균 지연 시간
```
1000 *
sum by (namespace) (rate(http_server_requests_seconds_sum{}[__interval]))
/
sum by (namespace) (rate(http_server_requests_seconds_count{}[__interval]))
```

2. histogram_quantile
```
1000 * histogram_quantile(0.95,
  sum by (namespace, uri, le) (
    rate(http_server_requests_seconds_bucket{uri!~"/[^/]+/monitor/prometheus|/[^/]+/monitor/healthcheck($|/.*)"}[1m])
  )
)
```

API별로 지연시간이 가지는 의미가 다 다르기 때문에

#### 

1. heavy user
 - 데이터를 많이 가진 User의 행위로 인해 평소보다 가파르게 CPU, Latency가 생기는 경우
 
2. 배치성 이벤트
 - Pod 수가 적은 야간 시간에 배치가 구동되면서 지연으로 인지하여 발생하는 경우

API 지연시간이 유의미한 기준을 가지고 있는지?
 -> 마이크로 서비스 별로 Latency라고 판단할 기준들이 다 다를 수 있음.

배치 수행으로 인해서 영향받은 Pod가 존재하고
그 경우 급격하게 CPU가 높아지거나 Latency가 생길 수 있다.
 -> 이것은 예외를 처리한다거나, 어떤 방식으로 처리할 수 있을지? 실제 트래픽을 받았다거나를 구분할 방법

Mute timing으로 설정해보았지만 헤비 유저가 해당 시간대에서만 사용한다는 보장이 없고
실제로 해당 API에 대한 해당 시간에 알람을 받지 못하는 것은 적절하지 않은듯 

평균 latency로만 가져가게 되면 Spike 탐지가 어렵다.
e.g,. 전체 요청 중 1%만 10초 걸린다 -> 평균 0.1초밖에 안 늘어남 (감지가 안됨)
 => histogram_quantile 필요

#### 쿼리 개선 방법

http_server_requests_seconds_sum
http_server_requests_seconds_count

위 두 쿼리를 사용해서 지연 시간을 표현한다면
해당 라벨로 조건을 얼만큼 걸 수 있는지를 확인해야한다.
sum의 경우, 
유의미한 label은 method="GET/POST/PUT", uri="api_path" 정도 있다.
count의 경우,
유의미한 label은 method, status, uri가 있다.


1. HTTP 요청 응답 시간의 95퍼센타일을 1분 단위로 계산하는 쿼리
```
histogram_quantile(0.95,
  sum by (namespace, le) (rate(http_server_requests_seconds_bucket{}[1m]))
)
```
histogram_quantile: 상위 5% 구간의 값을 계산한다.
rate(1m): 짧은 간격의 급격한 변화 감지
sum by (namespace, le): 서비스별 분포를 추적

---

고려해야할 사항
 1. Latency만을 기준으로 잡는 것은 기준을 높게 설정하고
 2. Latency + 장애 Count를 같이 보는건 어떨까? (실제로 문제 생겼을 때 - 10/29에는 4s정도로 Error Count도 같이 보인다.)
 3. GET은 짧게, 그 이외의 METHOD는 두 배 정도 길게
 4. latency 높으면서 + 충분히 트래픽이 있는 경우 (RPS ??)
 5. 
 